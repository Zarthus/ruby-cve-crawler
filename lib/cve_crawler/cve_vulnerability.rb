module CVE
  class Vulnerability
    SOFTWARE_EXTRACT_REGEXP = Regexp.new('[(, ]([^(), ]+)')

    def initialize(data)
      unless data.instance_of?(Hash)
        raise 'CVE Vulnerability needs to be initialized with a hash'
      end

      if malformed?(data)
        raise 'CVE Vulnerability data is malformed'
      end

      @identifier = data[:identifier]
      @date = data[:date]
      @description = data[:description]
      @link = data[:link]
      @title = data[:title]
      @affected_software = extract_software_from_title(data[:title])
    end

    attr_reader :identifier, :date, :description, :link, :title, :affected_software

    def malformed?(data)
      !(data.has_key?(:identifier) && data.has_key?(:date) && data.has_key?(:description) &&
          data.has_key?(:link) && data.has_key?(:title))
    end

    def extract_software_from_title(title)
      software = []

      title.scan(SOFTWARE_EXTRACT_REGEXP) do |scan|
        software << scan[0]
      end

      software.count == 0 ? nil : software
    end

    def affected_count
      @affected_software.nil? ? 0 : @affected_software.count
    end

    def equal?(cve_item, strict=false)
      return false unless cve_item.is_a?(Vulnerability)

      if strict
        return @identifier == cve_item.identifier && @link == cve_item.link && @date.utc.iso8601 == cve_item.date.utc.iso8601 &&
            @title == cve_item.title && @description == cve_item.description
      end

      @identifier == cve_item.identifier && @link == cve_item.link
    end

    def to_s
      "#{@title} - #{@link}"
    end

    def inspect
      "#<CVE::Vulnerability id=#{@identifier} affected=#{affected_count}>"
    end
  end
end
