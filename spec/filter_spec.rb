require_relative 'spec_helper'

describe CVE::Filter do
  it 'should filter repeated identifiers' do
    filter = CVE::Filter.new
    vulnerability = VulnerabilityMock.generate

    expect(filter.filter(vulnerability)).to equal(false)
    expect(filter.filter(vulnerability)).to equal(true)
  end

  it 'should not filter different identifiers' do
    filter = CVE::Filter.new

    3.times do
      expect(filter.filter(VulnerabilityMock.generate)).to equal(false)
    end
  end

  it 'should not exceed the history limit imposed' do
    filter = CVE::Filter.new

    filter_fill_history(filter, filter.history_size + 1)

    expect(filter.history.count).to eq(filter.history_size)
  end

  it 'should not exceed the history limit customly set' do
    filter = CVE::Filter.new(3)
    expect(filter.history_size).to eq(3)

    filter_fill_history(filter, filter.history_size + 1)

    expect(filter.history.count).to eq(filter.history_size)
  end

  it 'should not store duplicate history entries' do
    filter = CVE::Filter.new
    cve = VulnerabilityMock.generate

    filter.filter(cve)
    filter.filter(cve)

    expect(filter.history.count).to eq(1)
  end

  it 'should remove older history items first' do
    filter = CVE::Filter.new(1)
    cve = VulnerabilityMock.generate

    filter.filter(cve)
    filter.filter(VulnerabilityMock.generate)

    expect(filter.history[0]).not_to eq(cve)
  end

  it 'should remove older history items first' do
    filter = CVE::Filter.new(5)
    batches = []
    batch = []

    2.times do
      5.times do
        batch << VulnerabilityMock.generate
      end
      batches << batch
      batch = []
    end

    expect {
      batches.each do |vulns|
        vulns.each do |vuln|
          raise 'Unique filtered content was determined to be filtered?' if filter.filter(vuln) == true
        end
      end
    }.not_to raise_error

    history_ok = true
    5.times do |i|
      history_ok = history_ok && filter.history[i] == batches[1][i].identifier
    end
    expect(history_ok).to equal(true)
  end
end
